# Why I Matter Legacy :classical_building:

&nbsp;&nbsp;&nbsp;&nbsp;Because I grew up with it.  
&nbsp;&nbsp;&nbsp;&nbsp;Not as just a theory, but as a practice&mdash;with tools long gone, and code long hidden. Yet both are still alive&mdash;in my blood, and beneath the modern code.  
&nbsp;&nbsp;&nbsp;&nbsp;Let me guide you on a journey into the "Legacy"... through my childhood.

## Beginning of My Journey :mountain:

### Why I started programming :national_park:

&nbsp;&nbsp;&nbsp;&nbsp;The beginning was quite simple. Everything in our universe began from a simple thing or a thought. So as mine. I was a *12-year-old boy*, and I wanted to be a **hacker** &mdash;not the serious one, but only to prank my friends playfully like other hackers used to back then in the 90s-00s.&mdash; Same as the other boys of the same age, I just wanted to do *something special* that **no one could do**. That's why I started programming.

### How I started :book:

&nbsp;&nbsp;&nbsp;&nbsp;My dad was also a system engineer and was understanding of programming. So I asked my dad *I want to do programming* &mdash;I didn't say 'hacking,' obviously,&mdash; and a few days later, he bought me **a book** titled "*C language, beginning from 14, exciting game programming class* (14歳からはじめるC言語オンラインゲームプログラミング教室 - 大槻 有一郎)." &mdash;He couldn't find the book for under 14, because back then in Japan, programming skills were not considered as important as they are today.  
&nbsp;&nbsp;&nbsp;&nbsp;And, the book contained the installation media for *BCC Developer* and *Borland C++ compiler* as an appendix. That was the starting point for *over 20 years of my programming journey*.

## "Play" with Programming :game_die:

### Computer was my toy :video_game:

&nbsp;&nbsp;&nbsp;&nbsp;*I've been using computers* since I can remember. Mostly, I played games with it. But after I've learned programming, it changed the computer more than just a gaming machine. I was able to control the computer at the system level as the *ruler of the machine*, and breaking it or making it better **all depended on me**. That made me more attracted to the computer than to other game machines or toys.  
&nbsp;&nbsp;&nbsp;&nbsp;Spending hours in front of the computer, coding with it after school, and debugging on weekends. That's how I spent my time in my teenage years. **The computer was a toy**, and the *coding was a video game* for me that explored the IT world.

### How did I learn :cd:

&nbsp;&nbsp;&nbsp;&nbsp;However, learning programming in the early 2000s was not as easy as it is today. There wasn't much information on the internet, and no AI I could ask for help. I also had almost no one around me to ask. I could ask my dad, but programming was *not considered important* in Japan at that time, so most people simply weren't interested or didn't know anything about it.  
&nbsp;&nbsp;&nbsp;&nbsp;I just *"survived"* like a child suddenly thrown into the wild. I knew that I could give up, because it *wasn't forced* to continue and learn. But also, that is why I can continue. Unlike the school subjects or the homework, when I was coding, I was *free*. I was able to learn and experiment with **whatever I wanted**&mdash;unless I broke the computer&mdash;and it gave me the valid, certain results,&mdash;sometimes, the answers for my homework,&mdash; not like the numbers written in the corner of the sheet, which was for the test about the subjects that *we didn't know when to use.* That's why I could continue even without enough resources.

&nbsp;&nbsp;&nbsp;&nbsp;I read the references well enough, held them in one hand, and sometimes, followed my *instinct*. Learning programming was not easy for a 12-year-old boy, especially at that time without any guidance. But there was something I wanted to *create*, and when it formed the shape, it was so exciting. I could get something *special* that most of my friends could not get at that time. That's why I continued learning, I ***wanted*** to learn.  
&nbsp;&nbsp;&nbsp;&nbsp;Perhaps, I didn't learn. It was a joy for me to create something with my hands by coding. That's why I could learn coding without learning. I was just creating useful tools. I just *"played"* with coding.  
&nbsp;&nbsp;&nbsp;&nbsp;That's how I learned programming. No internet information, no AI, and no teacher. But also no class I must attend, no fancy pointless memorizations, and no test without meaning. Cut through the jungle by myself, walked across the plain, heading wherever I wanted to go, and built my palace on top of the hill.

### *Summary of my early programming (2000s)* :tv:

> #### *Summary:* :memo:
>
> - **Age Started**: *12*
> - **First Language**: *C (Borland C++)*
> - **Guided by...**: *A book about the C Language for 14-Year-Olds*
> - **IDE**: *BCC Developer / Borland C++*
> - **How to Learn**: *Trial & Error, instinct, printed references*
> - **Environment**: *Windows ME* (Be my friend if you have ever used this computer.)
> - No internet, no AI, no Stack Overflow, and no Teacher
>

## Project Development :man_technologist:

### Tools and technology :floppy_disk:

&nbsp;&nbsp;&nbsp;&nbsp;I used to use BCC Developer for coding C. It had a code editor, Borland C++ compiler, and basic project management tools, but no auto-complete and error checks in the editor. And I also didn't install a debugger in it. So I needed to do ***everything*** by myself. I needed to check and find the errors from the compiler *manually*, and to determine execution errors, output *all the data* to the console.  
&nbsp;&nbsp;&nbsp;&nbsp;I spent hours, or sometimes a day, to find a typo or just a single missing semicolon. Because there was no code analysis, no error highlighting, and no hints showed up while typing. Even a clickable error navigation. It was a text-highlighted, just a *"functional" text editor*. I need to input **all the characters** of the code with *my finger*, and I need to remember all the functions or search in the *book* every time.  
&nbsp;&nbsp;&nbsp;&nbsp;And if the error occurred at runtime, I needed to gather all the information *manually*, by outputting **everything** on the console to track all variable values and the execution flow. The system error message just shown, "Oh, hey! There is an error in your system. I'm shutting it down," and there were **no stack traces**, and **no hints** about what caused the error.

### Walking in the Darkness :flashlight:

&nbsp;&nbsp;&nbsp;&nbsp;Coding in the 2000s felt like *walking in the darkness*. When I fell down on the ground, I had no idea what caused it, and I had to jump off the cliff without knowing how high it was and what was waiting at the bottom. And was no one to stop me, *even if I'm heading in the wrong direction*. And when I was lost, I needed to find the way out by myself; there was no map and no one to tell me the direction to the exit.  
&nbsp;&nbsp;&nbsp;&nbsp;But also, that's why I can manage almost everything today. I can find a **clue** from almost *nothing* to fix the problem, and I can create something from *scratch*. I know the darkness and am used to it, and that's *not the fear for me*. That's an **exciting challenge** for me, because I know what's inside. Short of resources doesn't matter for me, because *I have **skills***.

&nbsp;&nbsp;&nbsp;&nbsp;***This is the real power of "Legacy Coding."***

### *Summary for Project Development* :wrench:

> #### *Summary:* :memo:
>
> - **Language & Tools**: *C (Borland C++) / BCC Developer*
> - **Environment**: *Text-only editor, no debugger, manual console output*
> - **Challenges**: *No error hints, no autocomplete, no documentation help*
> - **How I Debugged**: *Print everything, track flow manually, fix typos by instinct*
> - **Mindset**: *Coding was walking in the dark&mdash;but I learned to see in the dark*

## Why I started to dig in :pick:

### My grandpa :mage_man:

&nbsp;&nbsp;&nbsp;&nbsp;Surprisingly, my *grandpa* (my mom's dad) was a computer engineer too. He had a small electric store for ham radio, and **he built his own computer** using an Intel 8085 and *Assembly Language*. I found a beginner's guide book for Assembly programming after he passed away. In his era, he must have had absolutely *nothing* to help and guide him but the book. However, he survived and **created a system** to assist with his paperwork ***decades before** the world started switching from paper to digital*.  
&nbsp;&nbsp;&nbsp;&nbsp;It was not so easy for him to code in his era as same in mine; *it was even harder*. Before coding, *he needed to build a computer* in the first place to execute his code. And there was no shortcut in Assembly. He needed to manage **all parts of his computer** with his code; there were no default functions or libraries, and a line of raw code could move *only one part* of the machine *only once*. But at the same time, he could control **everything**. He controlled every single bit of memory, every single character on the screen, and every single blink of the LED light on his computer.  

&nbsp;&nbsp;&nbsp;&nbsp;This sounds astonishing and something special&mdash;and it is actually. But ***this is a foundation and the beginning of modern computing,** and he was standing in it.*

### Modern tools :computer:

&nbsp;&nbsp;&nbsp;&nbsp;These days, coding is way more relaxed than it used to be&mdash;colorful text highlights, auto-complete with mini lists, and real-time error checks. A lot of foolproofs, fail-safes, and even when an error occurs, *the system **automatically** collects the data* that caused the error. When you feel a little unsure about the use of the function, mouse over the function text, and the editor shows some small tips. If you need extra information, you can find a lot of it on the *internet* more than you can find inside a *book*, and if you need some help, you can find a lot of *communities on the internet*, and also able to ask the AI. Or some cases, the **AI will generate your code**.  
&nbsp;&nbsp;&nbsp;&nbsp;Also the programming languages itself is way smarter than my childhood. Built-in functions are easier to use, and there are a lot of libraries for many purposes. No need to think about memory structures, because *the compiler is handling it*. And some functions that we needed multiple lines when we used the legacy code, **it is only one line** in modern code, and you don't even need to think about what's inside it.

&nbsp;&nbsp;&nbsp;&nbsp;But these tools, libraries, and one-liner codes are *all found on the technologies that my grandpa and I used to use*. What I built in my childhood was stands on the technology my grandpa used, and what you are building today is all stands on the technology I used to use.

### I changed my career at 30 :nerd_face:

&nbsp;&nbsp;&nbsp;&nbsp;I used to be a lorry driver, and I had built a management system for delivery plans as my hobby. But one day, I realized that it is more comfortable to be in front of a PC monitor than driving a car, so I changed my career to a professional computer engineer when I was 30.  
&nbsp;&nbsp;&nbsp;&nbsp;While I was coding as a hobby, I cared about the memory use and functions behind a line of code. But because modern technologies are so helpful, many engineers *no longer need to understand* what is happening behind their code today. And when I saw the modern engineer code, it seems they are **relay on modern technologies**&mdash;*huge capacities of modern computers, and ready-to-use libraries*&mdash;and if it works, *they don't care* even if there are more efficient ways for the computer. Adding some lines of machine code does not have a huge effect on modern computers, although if it piles up, the effect appears more clearly. But no one cares about the machine code anymore, or perhaps ***they have no idea** about it*.

&nbsp;&nbsp;&nbsp;&nbsp;One such day, I found a book on my bookshelf about Assembly Programming for Intel 8085, which my grandpa used to read. And I realized that the code in the book is so **smart**, **efficient**, and has **no wasted moves** in it. It should be so because the capacity of a computer like the Intel 8085 was so small when the book was written. And I remember that I used to do the same thing with a computer with around 100MB of RAM.&mdash;It wasn't Assembly, but in C, though. Then I thought about modern programming, I couldn't help thinking I need to preserve and teach this to the next generations, to understand *how the machine works* and *why our code works*.

&nbsp;&nbsp;&nbsp;&nbsp;That's why I started to dig into the Legacy.

### Summary for Legacy Awakeness :lizard:

> #### *Summary:* :memo:
>
> - **Inspiration**: *My grandpa built a computer from scratch using Intel 8085 and Assembly*
> - **Realization**: *Modern code stands on forgotten brilliance and limitations of the past*
> - **Career Shift**: *From delivery driver to engineer at 30, carrying my childhood mindset*
> - **Concern**: *Modern developers don't care what's under the hood&mdash;but I do.*
> - **My Mission**: *Preserve and pass on the precision, discipline, and beauty of "Legacy"*

## To the Future :rocket:

### Abstraction and the Age of AI :robot:

&nbsp;&nbsp;&nbsp;&nbsp;The programming languages of today are becoming more abstract than they were yesterday. That is not a bad thing; actually, it is a great thing. It increases the efficiency of the production, and it is more safer machine to control the low-level machine controls instead of being hard-coded by humans. And in the future, &mdash;not so far&mdash; I think we don't even need to code anymore. The AI will take that part; we just need to think of the prompt to ask the AI, and it is already happening in some parts.  
&nbsp;&nbsp;&nbsp;&nbsp;That makes the programming more abstract than today. If that happens, people will no longer care about the code anymore as long as it works. And again, it is not a bad thing; it is much better to be built by a machine to increase the efficiency and decrease the "human" error, even some abstracted codes.

&nbsp;&nbsp;&nbsp;&nbsp;However, we still need the "Legacy" in the future. The AI and the abstracted code are very useful, as long as they work perfectly. But when something breaks, we have to look inside. To debug, to analyze, and to truly understand why it fails, we need to understand how it works beneath the surface of abstractions. And no matter how advanced the technology gets, you will always see the "Legacy" in there.

## Final Thought :thinking:

### This is not just My History :scroll:

&nbsp;&nbsp;&nbsp;&nbsp;Luckily, I could have seen the three generations of computing: machine-level computing, low-level but structured languages, and abstracted coding.  
&nbsp;&nbsp;&nbsp;&nbsp;These days, AI is taking a big part in computing, and thinking about low-level is not necessary for us anymore. In fact, we can get an IT job without coding, and code without thinking about how they work. And miraculously, they work perfectly. But, that is not a magic or some kind of miracle, that is because they all stand on the foundation of the "Legacy" that our ancestors precisely built one by one, line by line, with their very hands. And if you dig into the modern code, you will come across the low-level language that same as I used to use, and in the end, you will reach the machine code that same as my grandpa used to use.  
&nbsp;&nbsp;&nbsp;&nbsp;I wrote about "Legacy" coding through my personal history, but this is not just my history, but also the history that leads to modern computing. I experienced the history that became the foundation of today. But the people who start coding today will never experience those days that hard, but that was able to control everything. They will not crush the memory by missing a line, and will not crush the system by infinite recursions. But the "Legacy" is not what we left behind; it is a part of today.
